---
layout: post
title: 매트랩 실시간 GPS 정보
date: 2018-11-06 20:40:00 +0900
author: 원성규
excerpt: 매트랩에서 실시간으로 GPS 정보를 출력하기 위한 방안을 조합하고 있다.
categories:
- matlab
tags: 
- matlab
- gps
keyworkds:
---

### 시리얼 포트에 연결된 GPS 수신기 데이타 수집

시리얼 포트에 연결된 GPS 수신기에서 초당 10회 이하의 NMEA 문장이 입력된다.
시리얼 포트에 연결된 프로그램은 입력된 문장을 **모두** 제한된 시간에 처리해야만 한다. 
내 생각에는 입력된 데이타는 시간을 들이지 않고 버릴 수도 있고 제한된 시간내에 필요한 처리를 할 수도 있다. 그러나 최소한 유입되는 데이타를 읽지도 못한다면 이 시스템은 불능이고 이때 나타나는 현싱이 버퍼링이다.

### 간헐적인 에러

매트랩에서 입력된 문장을 분석하거나 콘솔에 그 내용을 출력할 때까지는 문제가 없었다.
그래픽 화면에 헤더마다 최신 정보를 출력했더니 시리얼 포트의 버퍼가 유지되는 듯하더니 어느 순간 차버렸다. 
이 단계까지는 입력 정보는 현재 시각보다 단 몇 초 전의 정보가 입력되었고 간헐적인 에러가 발생하였다.

### 버퍼링

마지막 단계는 `그래픽` 화면에 차트 하나 이상을 출력하는 것이다. 
이 단계에서는 입력 정보가 생성된 시각은 현재 시각과 30초 이상 차이났고 연속적인 에러가 발생하였다. 
시리얼 포트 `버퍼`가 항상 100%를 유지하기 때문에 그래픽을 동시에 처리하면 포트에 입력된 정보를 제한된 시간에 처리하지 못한다고 볼 수 있다.

### 로깅

이상의 정보를 확인하기 위하여 모든 입력에 대해서 현재 시각과 함께 문장 원형을 `로깅`하였다. 
포트 정보는 `fgetl` `매트랩` 함수를 사용하여 한 문장씩 읽었다. 
그리고 출력 항목들을 증감시키면서 문장의 생성 시각과 현재 시각에 시간 지연이 생기는 것을 확인하였고
이것이 처리되지 못한 버퍼 바이트가 차는 것과 관계가 있음을 확인하였다. 
버퍼 바이트는 기본값이 512인데 이 값을 최대인 4096으로 늘여도 그래픽 일거리를 늘여서 데이타 처리 용량을 넘어서면 순식간에 꽉찼다.

`매트랩` 함수 `fgetl`은 특수문자 `CR`과 `LF`를 감지해서 스트리밍 데이타를 구분하여 문장으로 인식한다. 이것을 콘솔 화면에 출력하면 한줄씩 출력된다고 생각하게 된다. 같은 함수를 다시 호출하면 다시 스트리밍에서 새 문장이 시작되고 끝을 탐색할 것이다.

`랩뷰`에서와 같이 애초에 문장 입력 함수가 아니라 `버퍼`를 직접 읽는 방식을 사용하면 다음과 같은 절차로 문장을 확보해야 한다.

- 작업 메모리에서 첫 문장을 추출
- 작업 메모리에서 문장이 성립하지 않으면 새 버퍼를 읽어서 작업 메모리에 추가

### 에러

`매트랩` 함수 `fgetl`를 사용할 때의 에러는 다음과 같다. 주로 버퍼링이 발생하면 데이터 입력에 시간 지연이 생기고 이어서 증상이 나타난다.

- `$G`로 시작하지 않음
- `LF`(함수가 전달한 버퍼의 끝) 이전에 NMEA 문장의 끝 표시 `*`가 없음
- 완전한 형식의 NMEA 문장이지만 체크섬 실패

### 서버

서버 코드를 포크시키거나 서버-클라이언트 코드를 각각 실행하여 클라이언트의 부담과 무관하게 서버에서는 시리얼 포트에서 안정적으로 데이타를 가져올 필요가 있다. 결과적으로 정보 화면 처리 코드에서 시리얼 포트를 직접 읽는 상황을 회피하면 될 듯하다. 어쩌면 매트랩 그래픽 처리가 너무 느리고 다른 언어에서는 잘 발생하지 않는 문제일 수도 있다.

### 반응형

그래픽이 모든 루프에 반응하지 않고 해당 항목만 반응형이면 어떨까?
분할 화면 10개 중에 하아에만 GPS 상태를 무한루프로 업데이트해도 CPU 1% 정도를 유지하여 큰 값을 보인다.
프로그램의 구조를 바꾸어서 이벤트 반응형 UI를 만들면 전체 화면에 그래프를 표시해도 버퍼링이 해결될 것이다.

이정도까지 고민했는데 매트랩에 갇혀 있어야할까? 매트랩을 잘쓰면 좋긴한데 그것만 잘쓰는 것이 목적이 아닐진대 `C++`이나 `Java` 전환해야하지 않을까?

`랩뷰`는 애초에 이벤트에 반응하는 그래프를 그린다고 볼 수 있다. 랩뷰 그래픽 객체는 미리 화면에 자리를 잡고 있고 데이타가 입력될 떄만 화면을 갱신한다. 데이타 파싱 모듈만 만들면 화면 처리 과정에서 발생했던 버퍼링 문제는 발생하지 않을 확률이 높다.

### 이벤트

생각해보니 `시뮬링크`에서는 이미 이벤트 방식의 빠른 그래픽이 구현되어 있다. 매트랩 GUI와 같은 현대적인 프로그래밍 방식을 사용해야 부지불식간에 성능을 높일 수 있을 듯하다. `Javascript` 웹 프로그래밍을 해도 이렇게 느리진 않을 것이다. 

```matlab
function Start_Callback(hObject, eventdata, handles)
axes(handles.axes1)
ezplot('sin(x)');
```

단 매트릭스 `솔버`를 운영해야 한다면 예외이다. 멀티쓰레드를 활용하여 내부적으로 분기를 해야한다면 이미 필요한만큼 적용되어 있을 것이고 일반적인 공학 솔버는 일방향적으로 자원을 최대한 활용하는 방식이기 때문이다.

### 결론

비유를 하자면 한손으로 데이타를 처리하면서 그래픽도 처리하고 있는 상황이다.
그래픽 처리를 하느라 일손이 바쁘면 처리할 데이타가 처리되지 못하고 쌓이게 되는데 이것이 버퍼링이다.
한손만 사용하는 해법은 데이타를 처리할 시간을 늘리기 위해서 그래픽 처리량을 줄이는 것이다.
화면 업데이트를 케이스 문장 내부로 옮기고 통계 정보는 강제로 10 문장마다 한번 출력으로 양을 줄였다.
그래도 기본 버퍼 512가 부족하여 버퍼를 4096으로 설정했다. 관측된 최대 버퍼링은 729이다.

다른 해법으로는 쓰레드를 나눠서 시리얼 통신 서버를 구동하는 것이다. 
클라이언트 본진에 무슨일이 있던지 일단 시리얼 포트의 버퍼링을 방지하고 읽은 데이타는 모두 화면에 출력하던지 시간이 부족하면 버리던지 알아서 할 일이다.

강제로 시간 지연을 주면 뭔가 좀 해소되지 않을까 기대를 했었는데 결과적으로 데이타를 처리할 시간동안 프로세스가 강제로 놀면서 버퍼만 채우게 되었다. 목적과 반대인 코드이다.

```matlab
java.lang.Thread.sleep(500);
```



